/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "Assignment2.h"

char **
pwd_1_svc(pwdd *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */
    char pwd1[1024];
    
    //getting the current directory path using chdir command
    chdir("/path/to/change/directory/to");
    
    //Storing the path in pwd1 variable
    getcwd(pwd1, sizeof(pwd1));
    
    //Storing the path in the result
    result = pwd1;
    
    //returning the result
	return &result;
}

char **
echo_1_svc(strings *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */
    //String the string value came from the client in result
    result =  argp->src ;
    
    //returning the result
	return &result;
}

char **
strconc_1_svc(FileExists *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */
    //filename variable for storing the name of the file
    char filename[999];
    
    //coopying the filename came from the client in filename varaible
    strcpy(filename,argp->p);
    FILE *file;
    
    //checking if file exists or not by simply trying to opening the file and reading it
    if(file = fopen(filename,"r"))
    {
        //returning the result
        result = "File exists";
        fclose(file);
    }
    else
    {
        //returning the result
        result = "File does not exists";
    }

    //returning the result
	return &result;
}

sort_request *
sorting_1_svc(sort_request *argp, struct svc_req *rqstp)
{
	static sort_request  result;

	/*
	 * insert server code here
	 */
    //Storing the size of elements number in result.p
    result.p= argp->p;
    int c,d,position,swap;
    
    //Bubble sort algorithm
    for ( c = 0 ; c < ( result.p - 1 ) ; c++ )
    {
        position = c;
        
        for ( d = c + 1 ; d < result.p ; d++ )
        {
            if ( argp->arr[position] > argp->arr[d] )
                position = d;
        }
        if ( position != c )
        {
            swap = argp->arr[c];
            argp->arr[c] = argp->arr[position];
            argp->arr[position] = swap;
        }
    }
    
    //Storing the result in an array
    for(c=0;c<result.p;c++)
    {
        result.arr[c]= argp->arr[c];
    }
    
    //returning the result
    return &result;
}

matrix_request *
matrix_multi_1_svc(matrix_input *argp, struct svc_req *rqstp)
{
	static matrix_request  result;

	/*
	 * insert server code here
	 */
    int mat1[2][2];
   
    //storing the values of matrix 1 in mat1
    mat1[0][0]= argp->arr1.arr[0];
    mat1[0][1]= argp->arr1.arr[1];
    mat1[1][0]= argp->arr1.arr[2];
    mat1[1][1]= argp->arr1.arr[3];
    
    int mat2[2][2];
   
    //storing the values of matrix 2 in mat1
    mat2[0][0]= argp->arr2.arr[0];
    mat2[0][1]= argp->arr2.arr[1];
    mat2[1][0]= argp->arr2.arr[2];
    mat2[1][1]= argp->arr2.arr[3];
    
    int multiply[2][2];
    
    //multiplication opeartion of two matrics
    int i, j, k;
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 2; j++)
        {
            multiply[i][j] = 0;
            for (k = 0; k < 2; k++)
                multiply[i][j] += mat1[i][k]*mat2[k][j];
        }
    }
    
    //storing the multiplication result in an 1-D array
    result.arr[0]=multiply[0][0];
    result.arr[1]=multiply[0][1];
    result.arr[2]=multiply[1][0];
    result.arr[3]= multiply[1][1];
    
    //returning the result
	return &result;
}
